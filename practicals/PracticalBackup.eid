//////////////////////////////////////////////////PRACTICAL TEST - RANGE CONTRACTION //////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////SETUP /////////

initialize() {



//set up filepaths	
defineConstant("mu", 1.67e-09);	
defineConstant("CAP", 200);	

defineConstant("outPref", "out_test_WF_2D");	
defineConstant("psmc_file", "/mnt/c/Users/Johnp/Documents/SlimFiles/fromHernan/Nipponia_softCollapse_gen3_varSCALE2.txt");
defineConstant("ranges_file", "/mnt/c/Users/Johnp/Documents/SlimFiles/fromHernan/Nipponia_softCollapse_gen3_varSCALE2_ranges.txt");
defineConstant("rho_file_in", "/mnt/c/Users/Johnp/Documents/SlimFiles/fromHernan/RecombFile.txt");
defineConstant("coord_file_in","/mnt/c/Users/Johnp/Documents/SlimFiles/fromHernan/GCF_000247815.1_FicAlb1.5_genomic.gff_for_SLiM.txt");


rho_file = readFile(rho_file_in);


defineConstant("L", asInteger(strsplit(rho_file[length(rho_file)-1],"\t")[2])); /// L= length of sequence
coord_file = readFile(coord_file_in);





//random seed
setSeed(rdunif(1, 0, asInteger(2^32) - 1));	

//// Model settings
initializeSLiMModelType("nonWF");                                                     ////non WF
defineConstant("LifeTable",c(1.0,1.0,1.0,0.8,0.6,0.4,0.2,0.1,0.05,0.0));               //// Life table should we choose to use it
initializeSLiMOptions(dimensionality="xy", nucleotideBased=T);  ////Nucleotide mode ///////////////////////////////////
initializeAncestralNucleotides(randomNucleotides(L+1)); /////Reference Nucl seq
	
	
defineConstant("S1", 0.1); // Max spatial competition distance
defineConstant("S2", 0.1); // Max spatial mating choice distance



defineConstant("start", clock());	////to track time
	
	
	
	
	
/// Set up an interaction for spatial competition
initializeInteractionType(1, "xy", reciprocal=T, maxDistance=S1); /////interaction ID, dimentions , reciprocal=T=interaction of a to = interactions of b to a, max distance of effect
i1.setInteractionFunction("n", 1.0 , S1/3);	
	
initializeInteractionType(2, "xy", reciprocal=T, maxDistance=S2);
i2.setInteractionFunction("n", 1.0, S2/3);	
	
	
	
	
	
//mutations	///for now all are neutral
initializeMutationTypeNuc("m1", 0.5, "f", 0.0);         // non-coding	
initializeMutationTypeNuc("m2", 0.5, "f", 0.0);         // synonymous	
initializeMutationTypeNuc("m3", 0.5, "f", 0.0);         // deleterious	
initializeMutationTypeNuc("m4", 0.5, "f", 0.0);         // beneficial	

	
	
	
//Create Chromosome Building Blocks	//Jukes Candor simplest mutation matrix, transition=transversion
initializeGenomicElementType("g1", c(m1,m2,m3,m4), c(0.25,0.25,0.25,0.25), mmJukesCantor(mu));   // exon	
initializeGenomicElementType("g2", c(m1,m2,m3), c(0.33,0.33,0.33), mmJukesCantor(mu));           // intron	
initializeGenomicElementType("g3", c(m1,m2), c(0.5,0.5), mmJukesCantor(mu));                     // non-coding	
	

///Construct Chromosome from Coordinate file
for (coord_line in coord_file)
{
	ROW = strsplit(coord_line, "\t");
	feature = ROW[2];

	if(feature=="exon") {
		initializeGenomicElement(g1, asInteger(ROW[3]), asInteger(ROW[4]));
	}	
	
	if(feature=="intron") {	
		initializeGenomicElement(g2, asInteger(ROW[3]), asInteger(ROW[4]));	
	}	
	
	if(feature=="non_coding") {	
		initializeGenomicElement(g3, asInteger(ROW[3]), asInteger(ROW[4]));	
	}	
	
}	

//Construct Recombination Landscape from file
rates = NULL;
ends = NULL;

for (rho_line in rho_file)
{
	components = strsplit(rho_line, "\t");
	ends = c(ends, asInteger(components[2])); //append to ends file
	rates = c(rates, asFloat(components[7])); //append to rates file
}

defineConstant("recomb_ends", ends); //define ends vector
defineConstant("recomb_rates", rates); //define rate vector
// initializeRecombinationRate(rates, ends); //recombination only needs those two things ends+rates
initializeRecombinationRate(1e-8);  ///// FLAT Reacombination Rate

// psmc file
file = readFile(psmc_file);
defineConstant("psmc", file); //for later use

// ranges file
file3 = readFile(ranges_file);
defineConstant("ranges", file3); //for later use

// initializeSex("A");

}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////// Initialisation Step!




1 early() {
	
sim.addSubpop("p1", 300);

p1.setSpatialBounds(c(0,0,1.0,1.0));

p1.individuals.setSpatialPosition(p1.pointUniform(1));
sim.setValue("pdfOpened", F);

// runif(25, 0, 1)
// seq(0, 1, length=9)

defineConstant("mapValues", rep(1.0,100));        ////////////// Create X values to be used in the map

p1.defineSpatialMap("map1", "xy", c(10,10), mapValues, interpolate=T,valueRange=c(0.0, 1.0), colors=c("red", "yellow")); ///////Create a map ontop of our spacial plane with different sections,with different values



defineConstant("pdfPath", writeTempFile("plot_", ".pdf", ""));
print(pdfPath);
sim.setValue("pdfOpened", F);
deleteFile("positions.txt");
	
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////
////// Functions

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////REPRODUCTION CALL


reproduction() {

// Give_Birth = (K/(size(sim.subpopulations.individuals)));
// Give_Birth=rbinom(1,1,0.1);
Give_Birth=rnorm(1,(CAP/(size(sim.subpopulations.individuals))),0.1);
interinds=i2.interactingNeighborCount(individual);

if ((Give_Birth>=1) & (interinds>0 )){


mate = i2.drawByStrength(individual, 1);

offspring = subpop.addCrossed(mate,individual);

newPos = individual.spatialPosition + runif(2, -0.02, 0.02);

offspring.setSpatialPosition(p1.pointReflected(newPos));


}
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////// FITNESS CALL

early() { /////fitness tunning
i1.evaluate();


inds = p1.individuals;////spatial competition provides density-dependent selection
competition = i1.totalOfNeighborStrengths(inds);
print(competition);
// competition = (competition + 1) / (2*PI * S1^2);
// competition = competition/(100*K);


location = inds.spatialPosition; ////////get the x and y value of each individual
optimum = p1.spatialMapValue("map1", location);
Values= competition - optimum ;
ages = inds.age;
// mortality = LifeTable[ages];  ///// USE LIFE TABLE


print(Values);

VeryLow=which(Values<0.1);



Values[VeryLow]=0; /// Cleansing of weak!

print(Values);



print('%%%%%%%%%%');



Negs=which(Values>=1.0);
Values[Negs]=1.0; /// Negative values not allowed!

// inds.fitnessScaling = 1.0 - Values;
// inds.fitnessScaling = inds.fitnessScaling * mortality;

// if (p1.individualCount>=K){
	
// inds.fitnessScaling = (inds.fitnessScaling - (min(inds.fitnessScaling)))/(max(inds.fitnessScaling)-min(inds.fitnessScaling));

// }


p1.fitnessScaling = CAP / (p1.individualCount);

print(Values);
print(inds.fitnessScaling);
print(p1.fitnessScaling);

print(paste(c('Population Size: ',p1.individualCount),'\t'));
print(paste(c('Generation: ',sim.generation),'\t'));

print(paste(c('Time: ',clock()-start),'\t'));
print(paste(c('Memory (MB): ',usage()),'\t'));


}





1:100 late(){


i2.evaluate();


if (sim.generation%10==0){

	P1pos=cbind(p1.individuals.x,p1.individuals.y);

	POS=P1pos;


	deleteFile("positions.txt");
	
		for (LINU in 0:(nrow(POS)-1)){

		writeFile("positions.txt",paste(POS[LINU,],"\t"),append=T);

		}

	system("python3 posplotter1.py --posfile positions.txt", wait=T);



	if (!sim.getValue("pdfOpened"))
		
	{

	system("mupdf -r 18 plot.pdf",wait=F);
	sim.setValue("pdfOpened", T);


	}

	else{
	system("pkill -HUP mupdf",wait=F);
	}

}



}





////// TRASH CODE ZONE
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





// 1:10000 late(){	

// for (ind in p1.individuals)  // individuals can move around a bit
// {
// newPos = ind.spatialPosition + runif(2, -0.02, 0.02);
// ind.setSpatialPosition(p1.pointReflected(newPos));
// }

// i2.evaluate();   ///then look for mates




// if (sim.generation%1000==0){

	// P1pos=cbind(p1.individuals.x,p1.individuals.y);

	// POS=P1pos;


	// deleteFile("positions.txt");
	
		// for (LINU in 0:(nrow(POS)-1)){

		// writeFile("positions.txt",paste(POS[LINU,],"\t"),append=T);

		// }

	// system("python3 posplotter1.py --posfile positions.txt", wait=T);



	// if (!sim.getValue("pdfOpened"))
		
	// {

	// system("mupdf -r 18 plot.pdf",wait=F);
	// sim.setValue("pdfOpened", T);


	// }

	// else{
	// system("pkill -HUP mupdf",wait=F);
	// }

// }




// }



// LL= sim.generation>=5000 ? 5  else 10; ////cool assignment method
// print(LL);
