//////////////////////////////////////////////////PRACTICAL TEST - RANGE CONTRACTION - GRADIENT CHANGE//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////// CUSTOM FUNCTIONZZZ  /////////////////////

function (f$)calcFST(o<Subpopulation>$ subpop1, o<Subpopulation>$ subpop2) //// Function to calculate FST given two populations
{
	p1_p = sim.mutationFrequencies(subpop1);
	p2_p = sim.mutationFrequencies(subpop2);
	mean_p = (p1_p + p2_p) / 2.0;
	H_t = 2.0 * mean_p * (1.0 - mean_p);
	H_s = p1_p * (1.0 - p1_p) + p2_p * (1.0 - p2_p);
	fst = 1.0 - H_s/H_t;
	fst = fst[!isNAN(fst)];  // exclude muts where mean_p is 0.0 or 1.0
	return mean(fst);
}


function (f$)genomicHeterozygosity(o<Genome>$ genome1, o<Genome>$ genome2) //// Calculates Genomic Diversity between two genomes
{
	muts1 = genome1.mutations;
	muts2 = genome2.mutations;
	unshared = setSymmetricDifference(muts1, muts2);
	pi = size(unshared) / L;
	return pi;
}

/*

  Estimate the average nucleotide heterozygosity in a subpopulation by sampling individuals at random and averaging the heterozygosity of all of the individuals sampled.  Note that this function normally uses a sample of individuals, of a size supplied in the optional parameter sampleSize; but if sampleSize is equal to the number of individuals in subpop, it will instead compute the heterozygosity exactly, as the mean of the heterozygosities of all individuals, rather than taking a sample.  For large subpopulations, that will of course be much slower than using a sample, however.

*/



function (f$)subpopHeterozygosity(o<Subpopulation>$ subpop, [i$ sampleSize=100]) //// Calcualte Genet Heterozygosity from a sample of Individuals of a pop
{
	if (sampleSize == subpop.individualCount)
		sampledIndividuals = subpop.individuals;
	else
		sampledIndividuals = sample(subpop.individuals, sampleSize, replace=T);
	
	pi_total = 0;
	for (individual in sampledIndividuals)
	{
		genomes = individual.genomes;
		individual_pi = genomicHeterozygosity(genomes[0], genomes[1]);
		pi_total = pi_total + individual_pi;
	}
	return pi_total / sampleSize;
}

////////////////////////////////////////////////////////////////// NEW Modified Functions for Windows   /////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


function (f$)genomicHeterozygosityWindow(o<Genome>$ genome1, o<Genome>$ genome2 ,integer$ window1 , integer$ window2 ) ///Calc heterozig between 2 genomes only for a certain window
{
	muts1 = genome1.mutations;
	muts1 = muts1[muts1.position>=window1 & muts1.position<=window2];
	
	muts2 = genome2.mutations;
	muts2 = muts2[muts2.position>=window1 & muts2.position<=window2];	
	
	unshared = setSymmetricDifference(muts1, muts2);
	pi = size(unshared) / (window2-window1);
	return pi;
}


function (f$)subpopHeterozygosityWindow( o<Subpopulation>$ subpop, integer$ window1, integer$ window2, [i$ sampleSize=100] ) ///Calc heteroz for a sample of inds from a pop BUT for a specific window
{
	if (sampleSize == subpop.individualCount)
		sampledIndividuals = subpop.individuals;
	else
		sampledIndividuals = sample(subpop.individuals, sampleSize, replace=T);
	
	pi_total = 0;
	for (individual in sampledIndividuals)
	{
		genomes = individual.genomes;
		individual_pi = genomicHeterozygosityWindow(genomes[0], genomes[1], window1 , window2);
		pi_total = pi_total + individual_pi;
	}
	return pi_total / sampleSize;
}



function (f$)sampleHeterozygosityWindow(  * sampledIndividuals , integer$ window1, integer$ window2) ///Calc heterozigo for a SPECIFIC group/sample of inds and specific window
{
	pi_total = 0;
	for (individual in sampledIndividuals)
	{
		genomes = individual.genomes;
		individual_pi = genomicHeterozygosityWindow(genomes[0], genomes[1], window1 , window2);
		pi_total = pi_total + individual_pi;
	}
	return pi_total / size(sampledIndividuals);
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////SETUP ///////////////////////

initialize() {



//set up filepaths	
defineConstant("mu", 1.67e-09);	
defineConstant("CAP", 1500);	

defineConstant("outPref", "out_test_WF_2D");	
defineConstant("psmc_file", "Nipponia_softCollapse_gen3_varSCALE2.txt");
defineConstant("ranges_file", "Nipponia_softCollapse_gen3_varSCALE2_ranges.txt");
defineConstant("rho_file_in", "RecombFile.txt");
defineConstant("coord_file_in","GCF_000247815.1_FicAlb1.5_genomic.gff_for_SLiM.txt");



paramtersfile = readFile('Parameters_File.txt');

defineConstant("ID", paste(strsplit(paramtersfile[0],'')[0:(length(strsplit(paramtersfile[0],''))-2)],''));
defineConstant("Capacity_Multiplier", asFloat(paramtersfile[1]));	
defineConstant("Start_DEC", asFloat(paramtersfile[2]));	
defineConstant("Start_INC", asFloat(paramtersfile[3]));	
defineConstant("Big_Timer", asFloat(paramtersfile[4]));	
defineConstant("Small_Timer", asFloat(paramtersfile[5]));	
defineConstant("decrease_amount", asFloat(paramtersfile[6]));	
defineConstant("competition_radius", asFloat(paramtersfile[7]));	
defineConstant("mating_radius", asFloat(paramtersfile[8]));	






rho_file = readFile(rho_file_in);


defineConstant("L", asInteger(strsplit(rho_file[length(rho_file)-1],"\t")[2])); /// L= length of sequence
coord_file = readFile(coord_file_in);





//random seed
setSeed(rdunif(1, 0, asInteger(2^32) - 1));	

//// Model settings
initializeSLiMModelType("nonWF");                                                      ////non WF
defineConstant("LifeTable",c(1.0,1.0,1.0,0.8,0.6,0.4,0.2,0.1,0.05,0.0));               //// Life table should we choose to use it
initializeSLiMOptions(dimensionality="xy", nucleotideBased=T);  ////Nucleotide mode ///////////////////////////////////
initializeAncestralNucleotides(randomNucleotides(L+1)); /////Reference Nucl seq
	
	
defineConstant("S1", 0.1); // Max spatial competition distance
defineConstant("S2", 0.1); // Max spatial mating choice distance



defineConstant("start", clock());	////to track time
	
	
	
	
	
/// Set up an interaction for spatial competition
initializeInteractionType(1, "xy", reciprocal=T, maxDistance=competition_radius); /////interaction ID, dimentions , reciprocal=T=interaction of a to = interactions of b to a, max distance of effect
i1.setInteractionFunction("n", 1.0 , competition_radius/3);	
	
initializeInteractionType(2, "xy", reciprocal=T, maxDistance=mating_radius);
i2.setInteractionFunction("n", 1.0, mating_radius/3);	
	
	
	
	
	
/////mutations	/////for now all are neutral
initializeMutationTypeNuc("m1", 0.0, "f", 0.0);         // non-coding	
initializeMutationTypeNuc("m2", 0.0, "f", 0.0);         // synonymous	
initializeMutationTypeNuc("m3", 0.0, "f", 0.0);         // deleterious	
initializeMutationTypeNuc("m4", 0.0, "f", 0.0);         // beneficial	

	
	
	
/////Create Chromosome Building Blocks	//////Jukes Candor simplest mutation matrix, transition=transversion
initializeGenomicElementType("g1", c(m1,m2,m3,m4), c(0.25,0.25,0.25,0.25), mmJukesCantor(mu));   // exon	
initializeGenomicElementType("g2", c(m1,m2,m3), c(0.33,0.33,0.33), mmJukesCantor(mu));           // intron	
initializeGenomicElementType("g3", c(m1,m2), c(0.5,0.5), mmJukesCantor(mu));                     // non-coding	
	

/////Construct Chromosome from Coordinate file
for (coord_line in coord_file){
		ROW = strsplit(coord_line, "\t");
		feature = ROW[2];

		if(feature=="exon") {
			initializeGenomicElement(g1, asInteger(ROW[3]), asInteger(ROW[4]));
		}	
		
		if(feature=="intron") {	
			initializeGenomicElement(g2, asInteger(ROW[3]), asInteger(ROW[4]));	
		}	
		
		if(feature=="non_coding") {	
			initializeGenomicElement(g3, asInteger(ROW[3]), asInteger(ROW[4]));	
		}	
		
	}	

/////Construct Recombination Landscape from file
rates = NULL;
ends = NULL;

for (rho_line in rho_file){////Recombination rates
		components = strsplit(rho_line, "\t");
		ends = c(ends, asInteger(components[2])); //append to ends file
		rates = c(rates, asFloat(components[7])); //append to rates file
	}

defineConstant("recomb_ends", ends); //define ends vector
defineConstant("recomb_rates", rates); //define rate vector
// initializeRecombinationRate(rates, ends); //recombination only needs those two things ends+rates
initializeRecombinationRate(1e-8);  ///// FLAT Reacombination Rate

// psmc file
file = readFile(psmc_file);
defineConstant("psmc", file); //for later use

// ranges file
file3 = readFile(ranges_file);
defineConstant("ranges", file3); //for later use

// initializeSex("A");

}












////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////// Initialisation Step!   ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




1 early() {
	
sim.addSubpop("p1", 300);

p1.setSpatialBounds(c(0,0,1.0,1.0));

p1.individuals.setSpatialPosition(p1.pointUniform(300));
sim.setValue("pdfOpened", F);

// runif(25, 0, 1)
// seq(0, 1, length=9)

// defineConstant("ID", paramtersfile[0]);


defineConstant("mapValues", rep(1.0,100));        ////////////// Create X values to be used in the map
p1.setValue("L", mapValues);     ///// List of map values
p1.setValue("REP", 0);           ///// Used for changing Enviromenet
p1.setValue("ENV_CAP",sum(mapValues)*Capacity_Multiplier);    ////Capacity of population size
p1.setValue("OUT",0);   //// Used for outputing files 

p1.setValue("LEN_WINDOW",100000);  ////length of window we want to do calculations/metrics on
p1.setValue("WINDOWS_XP",seq(0,sim.chromosome.lastPosition,100000));  ///// Split Chromosome into windows and store them


p1.defineSpatialMap("map1", "xy", c(10,10), mapValues, interpolate=T,valueRange=c(0.0, 1.0), colors=c("red", "yellow"));   ////set up the background capacity map 




defineConstant("pdfPath", writeTempFile("plot_", ".pdf", "")); ////used to init plotting

sim.setValue("pdfOpened", F);  ////////used to init plotting
deleteFile("positions.txt");  ////get rid previous runs
	
}







////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////REPRODUCTION CALL


reproduction() {////called for each indiv in each generation


//// Give_Birth=rbinom(1,1,0.1); //alt give birth trigger


Give_Birth=rnorm(1,(p1.getValue("ENV_CAP")/(size(sim.subpopulations.individuals))),0.1);  ////chance of giving birth for this individ
interinds=i2.interactingNeighborCount(individual);

if ((Give_Birth>=1) & (interinds>0 )){  ////if so, give birth


mate = i2.drawByStrength(individual, 1);

offspring = subpop.addCrossed(mate,individual);

newPos = individual.spatialPosition + runif(2, -0.02, 0.02);

offspring.setSpatialPosition(p1.pointReflected(newPos));

// print('BIRTH');
}
}









////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////// FITNESS CALL

early() {//////////fitness tunning
i1.evaluate();


inds = p1.individuals;     ////spatial competition provides density-dependent selection

competition = (i1.totalOfNeighborStrengths(inds) + 1) / (2*PI * S1^2);
competition = competition/(100*p1.getValue("ENV_CAP"));


location = inds.spatialPosition; ////////get the x and y value of each individual
optimum = p1.spatialMapValue("map1", location);

Values= optimum - competition ;



//////  Value fixing
	// VeryLow=which(Values<0.1);
	// Values[VeryLow]=0; /// Cleansing of weak!



	Negs=which(Values<0.0);
	Values[Negs]=0; /// Negative values not allowed!
/////



inds.fitnessScaling = inds.fitnessScaling * Values;       /////Multiplication with fitness


///// Mortality + fitness scaling to relative fitness
		// mortality = LifeTable[inds.age];  ///// USE LIFE TABLE
		// inds.fitnessScaling = inds.fitnessScaling * mortality;


		// if (p1.individualCount>=K){
			
		// inds.fitnessScaling = (inds.fitnessScaling - (min(inds.fitnessScaling)))/(max(inds.fitnessScaling)-min(inds.fitnessScaling));

		// }
/////


p1.fitnessScaling = p1.getValue("ENV_CAP") / (p1.individualCount);


/////////////////////////////////////// WELCOME TO THE DEBUG ZONE
//////////////////////////////////////
//////////////////////////////////////


// print('%%%%%%%%%%%%');
// print(competition);


// print('///////////');
// print(optimum);


// print('ZZZZZZZZZZZ');
// print(Values);


// print('XXXXXXXXXXXX');
// print(inds.fitnessScaling);


// print('CCCCCCCCCCCCCC');
// print(p1.fitnessScaling);


//////////////////////////////////////
////////////////////////////////////// 
//////////////////////////////////////

/////////////////////////////////////
/////Info on Run

print(paste(c('Population Size: ',p1.individualCount),'\t'));
print(paste(c('Generation: ',sim.generation),'\t'));

print(paste(c('Time: ',clock()-start),'\t'));
print(paste(c('Memory (MB): ',usage()),'\t'));


}








////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




1:55000 late(){ ///&&&&&&&&&& plotting, map value changing and other stuff  &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

GEN=sim.generation;
i2.evaluate();



	if ( (GEN%Big_Timer==0) & (p1.getValue("REP")<=3) & ( GEN < Start_INC ) & ( GEN>= (Start_DEC+Big_Timer) ) )
	{////////////// Moving into inner row of matrix //////////////////////////////////////////////////////////////////////////////////////////////////////

		REPO=p1.getValue("REP");
		p1.setValue("REP", (REPO+1));

	}/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


	if( (GEN%Small_Timer==0) & sum(p1.getValue("L")) > 4 & ( GEN < Start_INC ) & ( GEN>= Start_DEC ) )
	{//////////////// Changing values of row(layer) /////////////////////////////////
		
		REPZ=p1.getValue("REP");
		Li = p1.getValue("L");
		Li=matrix(Li,10,10);
		
		for ( REPO in 0:REPZ )
		{ 
			Li[REPO,(REPO+1):(ncol(Li)-(REPO+1))]=Li[REPO,(REPO+1):(ncol(Li)-(REPO+1))] - decrease_amount;		
			Li[REPO:(ncol(Li)-(1+REPO)),REPO]=Li[REPO:(ncol(Li)-(1+REPO)),REPO] - decrease_amount;			
			Li[nrow(Li)-(1+REPO),(REPO+1):(ncol(Li)-(REPO+1))]=Li[nrow(Li)-(1+REPO),(REPO+1):(ncol(Li)-(REPO+1))] - decrease_amount;			
			Li[(REPO+1):(nrow(Li)-(2+REPO)),nrow(Li)-(REPO+1)]=Li[(REPO+1):(nrow(Li)-(2+REPO)),nrow(Li)-(REPO+1)] - decrease_amount;
			

			Zeroz=which(Li<0.1); /// Get rid of The 1.38778e-16 BUG + anything that is <0
			Li[Zeroz]=0;
		}
		p1.defineSpatialMap("map1", "xy", c(10, 10), Li, interpolate=T,valueRange=c(0.0, 1.0), colors=c("black", "white"));
		p1.setValue("L", Li);
		p1.setValue("ENV_CAP",sum(Li)*Capacity_Multiplier);
		print(matrix(Li,10,10));
		
	}/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if (GEN==50000)
	{
	sim.outputFull(filePath='BurnInFileOut');

	}


	if ( ( GEN%Big_Timer==0 ) & ( p1.getValue("REP")>0 ) &  ( GEN>=(Start_INC) ) )
	{////////////// Map Values changing (plus) ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		REPO=p1.getValue("REP");
		p1.setValue("REP", (REPO-1));


	}/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if ( ( GEN%Small_Timer==0 ) & (sum(p1.getValue("L")) < 100) &  ( GEN>=Start_INC ) )
	{
		Li = p1.getValue("L");
		Li=matrix(Li,10,10);
		REPZ=p1.getValue("REP");
		
		for ( REPO in REPZ:4 )
		{ 
			Li[REPO,(REPO+1):(ncol(Li)-(REPO+1))]=Li[REPO,(REPO+1):(ncol(Li)-(REPO+1))] + decrease_amount;		
			Li[REPO:(ncol(Li)-(1+REPO)),REPO]=Li[REPO:(ncol(Li)-(1+REPO)),REPO] + decrease_amount;			
			Li[nrow(Li)-(1+REPO),(REPO+1):(ncol(Li)-(REPO+1))]=Li[nrow(Li)-(1+REPO),(REPO+1):(ncol(Li)-(REPO+1))] + decrease_amount;			
			Li[(REPO+1):(nrow(Li)-(2+REPO)),nrow(Li)-(REPO+1)]=Li[(REPO+1):(nrow(Li)-(2+REPO)),nrow(Li)-(REPO+1)] + decrease_amount;
			

			Onez=which(Li>0.9); /// Get rid of The 1.38778e-16 BUG + anything that is <0
			Li[Onez]=1;
		}

		
		p1.defineSpatialMap("map1", "xy", c(10, 10), Li, interpolate=T,valueRange=c(0.0, 1.0), colors=c("black", "white"));
		p1.setValue("L", Li);
		p1.setValue("ENV_CAP",sum(Li)*Capacity_Multiplier);
		print(matrix(Li,10,10));
		
	}




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////// Plots and Metrics




	// if (GEN%50==0 & GEN>=Start_INC & GEN<=Start_DEC)
	// {///////////// Live plotting of positions //////////////////////////////////////////////////////////////////////////////////////////////////////

		// P1pos=cbind(p1.individuals.x,p1.individuals.y); ///grab the positions

		// POS=P1pos;


		// deleteFile("positions.txt"); ///make sure to delete previous one
		
			// for (LINU in 0:(nrow(POS)-1))
			// {


			// writeFile("positions.txt",paste(POS[LINU,],"\t"),append=T);

			// }///print out positions in the file

		// system("python3 practplotter1.py --posfile positions.txt", wait=T);///activate the plot machine!



			// if (!sim.getValue("pdfOpened")) ////the first time the plotting is called
			// {

			// system("mupdf -r 18 plot.pdf",wait=F);
			// sim.setValue("pdfOpened", T);

			// }



			// else  ////all the other times
			// {
			// system("pkill -HUP mupdf",wait=F);
			// }


	// }//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Metric Generation



	if ( (GEN>=0 & GEN%250==0) | (GEN>=Start_DEC & GEN%2==0 & GEN<=(Start_DEC+3*(Big_Timer)))  )///when to make matrics//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	{
		OUT_HERE=p1.getValue("OUT");   /// Output file name indicator
		
		

		if (size(p1.individuals)>=100)
			{
			INDS=sample(p1.individuals,100,F); //// sample 100 individuals 
			}

			
		else
			{
			INDS=sample(p1.individuals,size(p1.individuals),F);	
			}
		// INDS.genomes.outputVCF(filePath=paste(c('Myvcf_',OUT_HERE,'.vcf'),''));     //// VCF output 

		

		MY_WINDOWS=p1.getValue("WINDOWS_XP"); /////Get the Windows
		LENGTH_OF_WINDOW=p1.getValue("LEN_WINDOW");  ////gap of windows

		mysamples = INDS; ////select random individuals for calcs

		deleteFile(paste(c('Hetero_',asString(ID),asString(OUT_HERE)),'')); ////get rid of prev runs file
		
		for (WINDOW in MY_WINDOWS[seq(0,size(MY_WINDOWS)-2,1)])
			{ ////go through windows

			HETERO=sampleHeterozygosityWindow(mysamples,WINDOW,WINDOW+LENGTH_OF_WINDOW); ////calc heterozy
			writeFile(paste(c('Hetero_',asString(ID),asString(OUT_HERE)),''),asString(HETERO),append=T); /////write it out in our file
		
			}
			
		writeFile(paste(c('Hetero_',ID,asString(OUT_HERE)),''),asString(GEN),append=T);
		writeFile(paste(c('Hetero_',ID,asString(OUT_HERE)),''),asString(p1.individualCount),append=T);
		
		p1.setValue("OUT",OUT_HERE+1); ///// renew value for next print
		
	}////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////







}///&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&